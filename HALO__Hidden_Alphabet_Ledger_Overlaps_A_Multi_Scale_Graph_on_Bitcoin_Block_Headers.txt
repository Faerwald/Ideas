Title: HALO  Hidden Alphabet Ledger Overlaps A Multi Scale Graph on Bitcoin Block Headers
Date:  2025-05-27
Source: HALO__Hidden_Alphabet_Ledger_Overlaps_A_Multi_Scale_Graph_on_Bitcoin_Block_Headers.pdf
HALO: Hidden-Alphabet Ledger Overlaps
       A Multi-Scale Graph on Bitcoin Block Headers
                           (Anonymous notes reorganized and expanded)
                                                May 1, 2025
                                                   Abstract
          This document describes HALO, a multi-scale directed graph derived from Bitcoin block-
      header partial collisions. The construction uses the first k identical hex nibbles of block hashes as
      “edges,” building a layered or stratified graph from these collisions. Each layer Ek corresponds
      to edges that share k identical hex nibbles (beyond the mandatory leading zeros imposed by
      Bitcoin’s proof-of-work). We discuss how to embed a hidden (yet publicly verifiable) message
      by deliberately engineering collisions, or simply by discovering naturally occurring collisions.
      We explore topological invariants, cycle-based encodings, motif detection, information capacity,
      and decoding procedures reminiscent of the “Key to the Extraterrestrial Messages” puzzle.
      Surprisingly, even in today’s Bitcoin blockchain (with ∼ 900,000 blocks), there is enough collision
      structure to encode kilobytes of self-verifying data in the ledger forever.
1    Introduction and Motivation
Bitcoin block headers are 80-byte structures, whose hash must meet a network-wide difficulty target
(thus starting with a certain number of bits set to zero). Beyond these mandatory leading zeros, it
is still possible that two block hashes coincide on a further k hex nibbles (i.e. 4-bit chunks), purely
by chance or by intentional “nonce sculpting.”
    Because there are now on the order of 900,000 block headers, we can represent each block hash
as a vertex in a large directed graph. We draw an edge hi → hj if and only if hi and hj share
an additional k nibbles beyond the difficulty-imposed prefix. Varying k from 1 to, say, 12 yields a
multi-scale or layered graph:                         [
                                           HALO =         Ek ,
                                                           k≥1
where Ek is the collection of edges arising from k-nibble collisions (beyond the consensus zeros).
   Why encode a message in such collisions? Among many reasons:
    • Steganographic permanence: Bitcoin is append-only and globally replicated; rewriting
      history to remove these collisions is essentially infeasible.
    • Verifiable timestamps: Each block hash is tied to a specific block height and is widely
      attested, providing a natural temporal anchor.
    • Physical/energetic cost to fake: Engineering high-grade collisions (large k) costs real
      hashing power, which deters spam or trivial forging.
                                                       1
    • Universal accessibility: Anyone with the block headers can reconstruct these collisions
      and confirm the existence (or absence) of special edges.
    • Game-theoretic attention: Partial-hash collisions are inherently interesting to cryptogra-
      phers and data archaeologists. They form a natural Schelling point for hidden but ultimately
      discoverable data.
    This document proceeds by laying out the formal graph structure, then discussing (1) how to
interpret and encode information topologically, (2) how to detect and decode that information, (3)
the estimated capacity for messages today and in the future, and (4) why multi-length collisions
(edges of different k) can convey even higher surprise than single-length collisions.
2     Graph Construction and Rarity Layers
2.1   Vertices
We associate one vertex to each Bitcoin block header’s hash, hi ∈ {0, 1}256 . The current blockchain
(as of writing) has on the order of 900,000 blocks, so |V | ≈ 9 × 105 .
2.2   Edges by k-Nibble Overlap
Define a directed edge hi → hj in layer Ek if hi and hj share an additional k identical hex nibbles
beyond the mandatory leading zeros.
               If the first k extra nibbles of hi and hj match, then (hi → hj ) ∈ Ek .
Equivalently, if you read the block hashes in big-endian hex, ignoring the leading zeros that are
forced by difficulty, you check how many additional hex nibbles coincide. We label each such edge
by k, or assign a weight w(hi , hj ) ≈ 16−k (reflecting the probability that such a collision occurs by
chance).
Expected number of edges in layer k. Two distinct hashes match on k additional hex nibbles
with probability 16−k = 2−4k . Since there are N ≈ 900,000 vertices, the total number of directed
pairs is N (N − 1). Thus:
                                    E[|Ek |] = N (N − 1) 16−k .
For large N , we often approximate N (N − 1) ≈ N 2 . For k = 8 (32 bits), we get an expected
N 2 × 16−8 ≈ 900,0002 /232 ≈ 8.8 × 101 = 88 edges. That is a small but non-trivial set of collisions.
2.3   Layered or Multiscale Graph
                       S
We denote HALO := k≥1 Ek , but in practice we focus on k = 1, . . . , 12. The edges of higher k are
rarer, so each k-layer can be interpreted as a distinct stratum.
    • Smaller k (e.g. k = 1, 2, . . . , 7): Overlaps happen more easily, producing a “dense” or
      “noisy” background graph.
    • Intermediate k (e.g. k = 8): Overlaps are rare but still frequent enough (dozens to hun-
      dreds) that they plausibly occur naturally.
    • Larger k (e.g. k ≥ 9): Extremely sparse. Edges in these higher strata are so unlikely that
      even a handful may indicate deliberate engineering.
                                                  2
3     Information Encoding: Topological Approaches
There are many ways to hide or encode signals in a large directed graph. Below we summarize four
major strategies (though in practice, a real hidden message might combine several of these).
3.1    Small-Subgraph (Motif ) Alphabet
Pick a finite set of “motifs” or small sub-graph configurations: e.g. directed 3-cycles, 4-cliques,
bow-ties, or special multi-length hinges. Assign each motif a symbol (a glyph, byte, or “codon”).
Then, as we look through the graph from smaller k to larger k, we see the appearance of these
motifs in some order. That ordered sequence of discovered motifs becomes the message. Rarer
edges (larger k) might carry more significance than edges in k = 8, etc.
3.2    Edge-Weight Morse Codes
Treat the rarity (weight) k as though it were a “dot/dash” length in Morse code. For instance,
define:
                                    k ∈ {8, 9} ⇒ dot (•) ,
                                    k ∈ {10, 11}       ⇒ dash (–) .
A self-avoiding walk (or cycle) that accumulates a particular pattern of dot/dash lengths can
represent a letter or symbol. One can incorporate a prime-length checksum (like the sum of k’s is
prime) to ensure unambiguous decoding.
3.3    Homology Class Tags
Use algebraic topology on each k-layer to find homology cycles (1-cycles) and pick a basis {γα }. A
path P in that layer has integer intersection numbers ⟨P, γα ⟩ measuring how many times P crosses
each basis cycle. Those intersection numbers form a vector of integers that can encode further
data. The advantage is that homology is robust to many small random changes in edges.
3.4    Knot Projection or Braid Encodings
Embed the entire HALO graph into S 3 by some consistent geometric mapping of vertices (e.g.
sorted by their numeric value as points along an axis). Partial collisions create edges that, in a
certain 3D projection, become braids. Which knot emerges when you close the braid can be used
as a symbol (e.g. trefoil knot = letter “A,” figure-eight = letter “B,” etc.). This is an explicitly
topological cipher, in principle immune to a relabeling of vertices.
4     Decoding Heuristics: Drawing on the “Key to the Extraterres-
      trial Messages”
Historically, a well-known puzzle called “The NSA Key to the Extraterrestrial Messages” described
a progressive hypothesis-testing approach to decipher an alien signal. A similarly robust strategy
applies here:
    1. Rarity Spectrum Detection. Plot |Ek | vs. k. By design, it will decay roughly like ≈
       N 2 × 16−k . If there is an anomalous cluster of edges at large k (like k = 9 or k = 10) that
       greatly exceeds Poisson predictions, it flags possible intentional data.
                                                   3
    2. Motif Mining. Enumerate simple cycles and small sub-graphs (3-cycles, 4-cycles, etc.). A
       deliberate code will produce far more structured patterns than random noise.
    3. Hypothesize Motif → Symbol Mappings. Try an assignment from each discovered motif
       to some letter/byte/codon. Generate a candidate message and measure its Shannon entropy
       or Kolmogorov complexity.
    4. Check for Self-Consistency. If the assignment is wrong, the resulting message looks
       random or inconsistent, with no short descriptions or repeat structures. If correct, the text’s
       frequency distribution flattens out to a near-uniform or a typical language distribution, and
       checksums line up.
    5. Iterate to Convergence. Once enough partial matches succeed, the probability that the
       code is correct skyrockets.
Such a procedure can typically unravel a well-designed hidden message from only partial guesses.
The final test is to verify internal checksums or repeated patterns.
5     Current Blockchain Scale Estimates
5.1    Numbers So Far
    • Vertices: N ≈ 9 × 105 Bitcoin block hashes.
    • Edges with k ≥ 8: The expected count is
                                      E[|E8 |] = N (N − 1) 16−8 ≈ 88,
       and for higher k we get drastically fewer edges: k = 9 might yield about 10 edges, k = 10 or
       k = 11 might yield ≤ 1 on average.
    • 3-Cycles using  k ≥ 8: If 5there are about 88 edges in E8 , the number of ways to pick triplets
                  88
      of edges is 3 ≈ 1.1 × 10 , which bounds the potential for 3-cycle-based motifs.
    From these numbers, even a handful of sculpted or unexpected overlaps in k ≥ 8 can become
a robust “signal” for an intended message. A designer could inject collisions (by repeated mining
attempts) to reliably produce tens or hundreds of 32-bit collisions, creating a kilobyte-scale hidden
message with internal redundancy.
5.2    Estimated Information Capacity
One straightforward measure of capacity is information-theoretic surprisality. If an event occurs
with probability pk = 16−k , then observing that event conveys
                                                  
                                   Ik = − log2 pk = 4k bits.
Hence one k = 8 collision is about 32 bits of surprise; a k = 9 collision is 36 bits, k = 10 is 40 bits,
etc.
Today, without special mining. We expect ≈ 88 edges for k = 8, each worth 32 bits of surprise,
so in total around 88 × 32 = 2816 bits ≈ 350 bytes. Real collisions can deviate from the Poisson
mean, but this is the ballpark. For k = 9 we expect ≈ 10 edges worth 36 bits each, i.e. ≈ 360
additional bits ≈ 45 bytes, and so on. Thus a kilobyte is not unreasonable.
                                                   4
With partial mining control. A pool controlling even 1% of global hash power can attempt
to engineer collisions over weeks or months. Nudging the nonce to produce, say, 50 collisions at
k = 9 is expensive but feasible. This drastically increases the number of edges in the top strata. If
a determined entity invests enough hashing power, they could embed tens or hundreds of kilobytes
while still making it look somewhat plausible at a cursory glance.
5.3   Potential Payloads
Since the capacity is on the order of kilobytes (or more if heavily engineered), we can embed:
    • A set of fundamental mathematical constants (π, e, ζ(3), prime tables).
    • Physical constants (α, me /mp , cosmic measurements) as expansions or continued fractions.
    • Pulsar/GW events (ephemeris data) to let a future decoder pinpoint the origin in space-
      time.
    • Medical / genomic snippets (short runs of compressed DNA).
    • Timestamp beacons or block-height references that anchor the data chronologically.
    • Cryptographic keys or signatures (public keys, short code to verify a larger off-chain
      archive).
   Even a modest 1–2 kB message can hold a surprising amount of universal or scientific content,
especially if efficiently compressed.
6     Message in the Graph Topology (Ignoring k-Labels)
Another perspective: suppose we do not use the numeric overlap lengths k as part of the code. We
only use which edges exist, ignoring their k-values. Then the semantic information sits purely in
the combinatorial structure of the directed graph (V, E).
6.1   Basic Capacity Bounds (Labeled vs. Unlabeled Graphs)
Labeled edges. There are M = N (N −1) ≈ 8.1×1011 possible directed edges among N ≈ 9×105
vertices. If a message chooses exactly E of them, then the number of distinct directed graphs with
E edges is                                      
                                                M
                                                    .
                                                E
The log2 of that binomial is an upper bound on the number of bits we can encode:
                                                    
                                                     M
                                     Hmax ≈ E log2       ,
                                                     E
ignoring smaller-order terms.
   For instance, with E = 100 carefully engineered edges, we get
                Hmax ≈ 100 × log2 (8.1 × 109 ) ≈ 100 × 33 = 3300 bits ≈ 400 bytes.
That is if we treat all vertices as labeled and we pick which 100 edges exist.
                                                 5
Unlabeled (isomorphism) viewpoint. Two labeled graphs that are isomorphic might repre-
sent the same topological pattern. Thus we must divide by the size of the automorphism group
|Aut(G)|. For a sparse random graph, automorphisms are typically trivial, so the capacity is only
moderately reduced (by at most a factor up to E! for E edges). Numerically, E! is huge, but
log2 (E!) is on the order of E log2 E, still not catastrophic if E is only a few hundred or thousand.
    Hence the purely topological capacity of a 100-edge subgraph on N ≈ 9 × 105 nodes is still easily
in the range of hundreds of bytes.
6.2    Practical Decoding (Ignoring k)
A practical pipeline:
    1. Extract edges that surpass some threshold (e.g. k ≥ 9). Remove the rest to get a small,
       sparse subgraph G.
    2. Apply canonical labeling (via a tool like nauty or bliss) to factor out any arbitrary
       reorderings.
    3. Identify small motifs (3-cycles, cliques, . . . ). Hypothesize an alphabet assignment (motif
       → symbol).
    4. Compute checksums, entropy, etc. If the message is correct, it will have consistent
       structure.
Thus even ignoring the numeric values of k, hundreds to thousands of bits can be stably placed.
7     Multi-Length Collision Motifs: Exponential Rarity
7.1    Why Mixed-Length Overlaps are Extremely Rare
Consider a single block hash h∗ (a “hub”). The probability it has an outgoing edge to hj at length k
                                                                                                           ′
is 16−k . For two distinct lengths k and k ′ , the probability that h∗ has both such edges is 16−(k+k ) .
This extra factor can make multi-length overlaps effectively vanish in a random setting—any such
occurrence is an enormous anomaly.
    Likewise, a triangle with edges of length k1 , k2 , k3 has probability 16−(k1 +k2 +k3 ) . Even for k = 8
repeated thrice, that is 16−24 , so among N3 ≈ 1.2 × 1017 triangles, we expect only a fraction of
one triangle to appear! In practice, we see almost none unless it is deliberately created.
      Motif                             Example           Probability            Expected Count
      Single edge                         k=8                16−8              ≈ 88 (directed edges)
      Dual-length “vee” from node        k = 8, 9    16−8 × 16−9 = 16−17       ≪ 10−7 for each node
                                                       (16−8 )3 = 16−24        ≈ N3 16−24 ≈ 0.004
                                                                                    
      Equal-length triangle               k=8
      Mixed-length triangle              (8, 8, 9)    16−(8+8+9) = 16−25           ≈ 2.7 × 10−4
Table 1: Exponential rarity of multi-length collisions. Even a handful of such motifs would be a
huge anomaly.
                                                     6
7.2    Encoding with Multi-Color (Multi-k) Motifs
We can directly treat each k as a “color.” Then certain multi-color configurations are so improbable
that they must be deliberate if observed. For example:
    • Colored Edge: A single edge of length k (encoded as color k). This might convey 4 bits
      (k − 8 in {0, . . . , 7}).
    • Dual-Length Hinge (“V-shape”): A node with two outgoing edges of distinct lengths
      k1 , k2 . Probability under random null is 16−(k1 +k2 ) , extremely tiny for large k1 , k2 .
    • Triple Collision (Triangle) of same k: Probability 16−3k . This can store 3 × 4 = 12 bits
      (for k = 8, 9, . . . ) or function as a robust codeword with parity checks.
    • Mixed Triangle (k1 , k2 , k3 ): Even more surprising. The ordered triple can convey 12–20
      bits.
    • High-Degree Rainbow Hub: If a single node has edges of m distinct k-colors emanating
      from it, that is like a paragraph delimiter or special marker, since under random chance the
      expected count is negligible.
   In practice, discovering even 10 such multi-color motifs reliably yields hundreds of bits of infor-
mation. Larger engineering yields kilobytes of payload.
8     Practical Steps for Implementation and Discovery
Implementation Outline for a Sender (the message planter):
    1. Harvest real HALO graph so far. Pull all existing block headers, compute partial colli-
       sions for k = 1, . . . , 12, store adjacency lists per k-layer.
    2. Design a code (e.g. multi-length motifs or large k edges) that can hold your intended
       message.
    3. Deliberate collisions: If you have partial control over block creation (like a mining pool),
       tweak nonces in an attempt to produce a block hash h that collides with a prior block on
       k = 9, 10, . . . . This can be done sporadically over time.
    4. Insert redundancy and checksums so that any partial success still reveals your data with
       high confidence.
    5. Publish a decoding guide referencing topological or subgraph-based instructions (like a
       new “Key to the Extraterrestrial Messages”).
Implementation Outline for a Finder/Decoder :
    1. Scan the entire chain and build {Ek }12
                                            k=1 . Count |Ek | for each k.
    2. Look for anomalies:
         • Does |Ek | deviate significantly from the Poisson expectation N (N − 1)16−k ?
         • Are there unexpectedly many multi-k hubs or triangles?
                                                  7
    3. Focus on rare strata: k ≥ k0 where k0 might be chosen so that |Ek0 | or higher is suspiciously
       large.
    4. Graph canonicalization: Use nauty/bliss to reduce label noise.
    5. Motif mining (search for sub-graphs: 3-cycles, 4-cliques, etc.). Attempt a mapping from
       each motif to a symbol.
    6. Iteratively refine that mapping by checking for:
         • near-uniform symbol frequencies,
         • meaningful checksums,
         • or well-known constants/patterns in the decoded symbol stream.
    7. Confirm final message and see if it references known mathematics, a pulsar map, or a
       cryptographic key.
9     Conclusions and Key Takeaways
    • HALO is a layered (multi-k) directed graph on ≈ 900,000 vertices (one per block).
      Even for k = 8 (32 extra bits), we expect dozens of collisions; for k = 9, only a handful; for
      k ≥ 10, extremely few.
    • Messages can be hidden in the graph structure, using either:
         1. The rarity values k (viewing them as dot/dash codes or multi-color edges),
         2. The plain topology of which edges appear (ignoring k), or
         3. Algebraic topology, e.g. homology cycles and braids.
    • Capacity estimates:
         – Passive (existing blocks, random collisions): ∼ kilobyte-scale messages are feasible.
         – Active, partial hash-power control : tens of kilobytes or more, if one invests the cost of
           engineering many k = 9, 10, . . . collisions over time.
    • Detection and decoding are relatively straightforward once one suspects the existence of
      a code. The graph can be built in minutes on standard hardware, and anomalies at k ≥ 8
      are easy to spot.
    • Future significance: If a hidden message is indeed placed within the chain, it remains
      immutable and globally notarized. Future archaeologists can decode it with no reliance on
      external references, leveraging the universal mathematics and topological structure that come
      “for free” with the blockchain data.
Final Note: Even a single multi-length collision motif (e.g. a triangle of edges with k = 9, 10, 10)
would be extraordinarily unlikely under null conditions. Its presence would serve as an immediate
multi-sigma indicator of an intentional message. This is reminiscent of prime numbers in classical
SETI protocols: the rarity of large prime patterns signals intelligence. Here, the exponentiated
improbability of repeated partial-hash collisions might serve an identical role.
                                                  8